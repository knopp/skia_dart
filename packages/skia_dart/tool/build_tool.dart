import 'dart:convert';
import 'dart:io';
import 'dart:math';

import 'package:args/command_runner.dart';
import 'package:crypto/crypto.dart';
import 'package:path/path.dart' as p;

void main(List<String> arguments) async {
  final runner =
      CommandRunner<void>(
          'built_tool',
          'Skia Dart build tool',
        )
        ..addCommand(ListCommand())
        ..addCommand(GenCommand())
        ..addCommand(SkiaHashCommand())
        ..addCommand(UpdateHashCommand())
        ..addCommand(CheckHashCommand());

  await runner.run(arguments);
}

String getWorkspaceRoot() {
  return p.canonicalize(
    p.join(
      p.dirname(Platform.script.toFilePath()),
      '..',
      '..',
      '..',
    ),
  );
}

// skia_dart_hash is generated by combining the Skia submodule commit hash
// with a git directory hash of the src folder (where the Skia wrapper resides).
String generateSkiaDartHash(String workspaceRoot) {
  // Get the Skia submodule commit hash
  final skiaHashResult = Process.runSync(
    'git',
    ['rev-parse', 'HEAD:skia'],
    workingDirectory: p.join(workspaceRoot),
  );
  if (skiaHashResult.exitCode != 0) {
    throw Exception(
      'Failed to get Skia submodule hash: ${skiaHashResult.stderr}',
    );
  }
  final skiaHash = (skiaHashResult.stdout as String).trim();

  // Get the git tree hash of the src directory
  final srcTreeResult = Process.runSync(
    'git',
    ['rev-parse', 'HEAD:src'],
    workingDirectory: workspaceRoot,
  );
  if (srcTreeResult.exitCode != 0) {
    throw Exception(
      'Failed to get src directory hash: ${srcTreeResult.stderr}',
    );
  }
  final srcHash = (srcTreeResult.stdout as String).trim();

  // Combine both hashes using SHA-1
  final combined = '$skiaHash$srcHash';
  final digest = sha1.convert(utf8.encode(combined));
  return digest.toString();
}

class BuildConfig {
  final String name;
  final Map<String, Object> options;

  BuildConfig({
    required this.name,
    required this.options,
  });

  BuildConfig copyDebug() {
    return BuildConfig(
      name: '${name}_debug',
      options: {...options, 'is_debug': true},
    );
  }

  Map<String, Object> optionsFull() {
    final options = Map<String, Object>.from(this.options);
    if (options.containsKey('is_debug') != true) {
      options['is_official_build'] = true;
      options['skia_enable_optimize_size'] = true;
    }
    final targetOs = options['target_os'] as String;
    if (targetOs == 'win') {
      options['clang_win'] = 'C:\\Program Files\\LLVM';
    }
    if (targetOs == 'mac' || targetOs == 'ios') {
      options['skia_use_harfbuzz'] = false;
    }
    if (options['skia_use_harfbuzz'] != false) {
      options['skia_use_system_harfbuzz'] = false;
    }
    if (targetOs == 'linux' || targetOs == 'android') {
      options['skia_use_system_freetype2'] = false;
    }
    options['skia_use_system_expat'] = false;
    options['skia_use_system_icu'] = false;
    options['skia_use_system_libjpeg_turbo'] = false;
    options['skia_use_system_libpng'] = false;
    options['skia_use_system_libwebp'] = false;
    options['skia_use_system_zlib'] = false;

    if (targetOs == 'android') {
      final ndkFromEnv = Platform.environment['ANDROID_NDK_HOME'];
      if (ndkFromEnv != null) {
        options['ndk'] = ndkFromEnv;
      }
    }

    return options;
  }

  static List<BuildConfig> loadDefaultList({
    bool onlyLocal = false,
    bool skipAndroid = false,
    bool debug = false,
  }) {
    final configPath = p.join(
      p.dirname(Platform.script.toFilePath()),
      'build_config.json',
    );
    final jsonString = File(configPath).readAsStringSync();
    final jsonData = jsonDecode(jsonString) as Map<String, dynamic>;
    final res = _fromJson(jsonData);
    return res
        .where((config) {
          final targetOs = config.options['target_os'] as String;
          if (targetOs == 'android') {
            return !skipAndroid;
          }
          if (onlyLocal) {
            if (Platform.isMacOS) {
              return targetOs == 'mac' || targetOs == 'ios';
            } else if (Platform.isWindows) {
              return targetOs == 'win';
            } else if (Platform.isLinux) {
              return targetOs == 'linux';
            } else {
              return false;
            }
          }
          return true;
        })
        .expand((e) {
          if (debug) {
            return [e, e.copyDebug()];
          } else {
            return [e];
          }
        })
        .toList(growable: false);
  }

  static List<BuildConfig> _fromJson(Map<String, dynamic> json) {
    final configs = <BuildConfig>[];
    json.forEach((key, value) {
      if (value is Map<String, dynamic>) {
        configs.add(BuildConfig(name: key, options: value.cast()));
      } else {
        throw FormatException('Invalid config format for $key');
      }
    });
    return configs;
  }
}

class ListCommand extends Command<void> {
  @override
  final String name = 'list';

  @override
  final String description = 'List available build configurations.';

  ListCommand() {
    argParser.addFlag(
      'only-local',
      help:
          'Only list configurations that can be built on the current platform.',
      negatable: false,
    );
    argParser.addFlag(
      'skip-android',
      help: 'Skip Android configurations.',
      negatable: false,
    );
    argParser.addFlag(
      'debug',
      help: 'Also include debug variants of the configurations.',
      negatable: false,
    );
  }

  @override
  void run() {
    final config = BuildConfig.loadDefaultList(
      onlyLocal: argResults!['only-local'] as bool,
      skipAndroid: argResults!['skip-android'] as bool,
      debug: argResults!['debug'] as bool,
    );
    for (final c in config) {
      print(c.name);
    }
  }
}

class GenCommand extends Command<void> {
  @override
  final String name = 'gen';

  @override
  final String description = 'Generate build files for the target platform.';

  GenCommand() {
    argParser.addOption(
      'build-config',
      help: 'Name of the build configuration to generate.',
      allowed: BuildConfig.loadDefaultList(
        debug: true,
      ).map((c) => c.name),
    );
  }

  @override
  void run() {
    final config = BuildConfig.loadDefaultList(
      debug: true,
    ).firstWhere((c) => c.name == argResults!['build-config']);
    final workspaceRoot = getWorkspaceRoot();
    final outDir = p.join(workspaceRoot, 'out', config.name);
    final argsGn = p.join(outDir, 'args.gn');
    final argsContent = StringBuffer();
    for (final entry in config.optionsFull().entries) {
      final value = entry.value;
      if (value is String) {
        argsContent.writeln('${entry.key} = "$value"');
      } else if (value is bool) {
        argsContent.writeln('${entry.key} = $value');
      } else {
        throw FormatException(
          'Unsupported value type for ${entry.key}: ${value.runtimeType}',
        );
      }
    }
    Directory(outDir).createSync(recursive: true);
    File(argsGn).writeAsStringSync(argsContent.toString());

    final exe = Platform.isWindows ? '.exe' : '';
    Process.runSync(
      p.join('bin', 'gn$exe'),
      ['gen', p.join('..', 'out', config.name)],
      workingDirectory: p.join(workspaceRoot, 'skia'),
      runInShell: true,
    );
  }
}

class SkiaHashCommand extends Command<void> {
  @override
  final String name = 'skia-hash';

  @override
  final String description = 'Generate the skia_dart_hash.';

  @override
  void run() {
    final workspaceRoot = getWorkspaceRoot();
    final hash = generateSkiaDartHash(workspaceRoot);
    print(hash);
  }
}

class UpdateHashCommand extends Command<void> {
  @override
  final String name = 'update-skia-hash';

  @override
  final String description = 'Update the skia_dart_hash in package root';

  @override
  void run() {
    final workspaceRoot = getWorkspaceRoot();
    final hash = generateSkiaDartHash(workspaceRoot);
    final packageRoot = p.join(workspaceRoot, 'packages', 'skia_dart');
    final hashFile = p.join(packageRoot, 'skia_dart_hash');
    File(hashFile).writeAsStringSync(hash);
  }
}

class CheckHashCommand extends Command<void> {
  @override
  final String name = 'check-skia-hash';

  @override
  final String description = 'Check if the skia_dart_hash is up to date.';

  @override
  void run() {
    final workspaceRoot = getWorkspaceRoot();
    final expectedHash = generateSkiaDartHash(workspaceRoot);
    final packageRoot = p.join(workspaceRoot, 'packages', 'skia_dart');
    final hashFile = p.join(packageRoot, 'skia_dart_hash');
    if (!File(hashFile).existsSync()) {
      throw Exception(
        'skia_dart_hash file does not exist. Please run update-skia-hash command.',
      );
    }
    final actualHash = File(hashFile).readAsStringSync().trim();
    if (expectedHash != actualHash) {
      throw Exception(
        'skia_dart_hash is out of date. Please run update-skia-hash command.',
      );
    }
    print('skia_dart_hash is up to date.');
  }
}
