part of '../skia_dart.dart';

/// Selects whether Skia may internally cache [SkBitmap] generated by decoding
/// [SkImage], or by copying [SkImage] from GPU to CPU.
///
/// Choose [disallow] if [SkImage] pixels are to be used only once, or if
/// [SkImage] pixels reside in a cache outside of Skia, or to reduce memory
/// pressure.
///
/// Choosing [allow] does not ensure that pixels will be cached. [SkImage]
/// pixels may not be cached if memory requirements are too large or pixels
/// are not accessible.
enum SkImageCachingHint {
  /// Allows internally caching decoded and copied pixels.
  allow(sk_image_caching_hint_t.ALLOW_SK_IMAGE_CACHING_HINT),

  /// Disallows internally caching decoded and copied pixels.
  disallow(sk_image_caching_hint_t.DISALLOW_SK_IMAGE_CACHING_HINT),
  ;

  const SkImageCachingHint(this._value);
  final sk_image_caching_hint_t _value;
}

/// Type of texture compression used for compressed image data.
enum SkTextureCompressionType {
  /// No compression.
  none(sk_texture_compression_type_t.NONE_SK_TEXTURE_COMPRESSION_TYPE),

  /// ETC2 RGB8 unorm compression (commonly used on mobile GPUs).
  etc2Rgb8Unorm(
    sk_texture_compression_type_t.ETC2_RGB8_UNORM_SK_TEXTURE_COMPRESSION_TYPE,
  ),

  /// BC1 RGB8 unorm compression (also known as DXT1, commonly used on desktop GPUs).
  bc1Rgb8Unorm(
    sk_texture_compression_type_t.BC1_RGB8_UNORM_SK_TEXTURE_COMPRESSION_TYPE,
  ),

  /// BC1 RGBA8 unorm compression (DXT1 with 1-bit alpha).
  bc1Rgba8Unorm(
    sk_texture_compression_type_t.BC1_RGBA8_UNORM_SK_TEXTURE_COMPRESSION_TYPE,
  ),
  ;

  const SkTextureCompressionType(this._value);
  final sk_texture_compression_type_t _value;
}

/// Controls whether rescaling is done in the image's gamma or in linear space.
enum SkImageRescaleGamma {
  /// Rescale in the image's original gamma space.
  src(sk_image_rescale_gamma_t.SK_IMAGE_RESCALE_GAMMA_SRC),

  /// Transform to linear gamma before rescaling, then transform back.
  ///
  /// This produces more accurate results but is more expensive.
  linear(sk_image_rescale_gamma_t.SK_IMAGE_RESCALE_GAMMA_LINEAR),
  ;

  const SkImageRescaleGamma(this._value);
  final sk_image_rescale_gamma_t _value;
}

/// Controls the technique (and cost) of image rescaling.
enum SkImageRescaleMode {
  /// Nearest neighbor sampling - fastest but lowest quality.
  nearest(sk_image_rescale_mode_t.SK_IMAGE_RESCALE_MODE_NEAREST),

  /// Bilinear interpolation - good balance of speed and quality.
  linear(sk_image_rescale_mode_t.SK_IMAGE_RESCALE_MODE_LINEAR),

  /// Repeated linear interpolation for better downscaling quality.
  repeatedLinear(sk_image_rescale_mode_t.SK_IMAGE_RESCALE_MODE_REPEATED_LINEAR),

  /// Repeated cubic interpolation for highest quality downscaling.
  repeatedCubic(sk_image_rescale_mode_t.SK_IMAGE_RESCALE_MODE_REPEATED_CUBIC),
  ;

  const SkImageRescaleMode(this._value);
  final sk_image_rescale_mode_t _value;
}

/// Describes a two dimensional array of pixels to draw.
///
/// The pixels may be decoded in a raster bitmap, encoded in a [SkPicture] or
/// compressed data stream, or located in GPU memory as a GPU texture.
///
/// [SkImage] cannot be modified after it is created. [SkImage] may allocate
/// additional storage as needed; for instance, an encoded [SkImage] may decode
/// when drawn.
///
/// [SkImage] width and height are greater than zero. Creating an [SkImage] with
/// zero width or height returns null.
///
/// [SkImage] may be created from [SkBitmap], [SkPixmap], [SkSurface],
/// [SkPicture], encoded streams, GPU texture, or hardware buffer. Supported
/// encoded formats include BMP, GIF, HEIF, ICO, JPEG, PNG, WBMP, and WebP.
///
/// Example:
/// ```dart
/// // Load an image from encoded data
/// final data = SkData.fromFile('image.png');
/// final image = SkImage.fromEncoded(data!);
/// if (image != null) {
///   print('Image size: ${image.width} x ${image.height}');
///   canvas.drawImage(image, offset, paint);
///   image.dispose();
/// }
/// data.dispose();
/// ```
class SkImage with _NativeMixin<sk_image_t> {
  SkImage._(Pointer<sk_image_t> ptr) {
    _attach(ptr, _finalizer);
  }

  @override
  void dispose() {
    _dispose(sk_image_unref, _finalizer);
  }

  // Factory methods

  /// Creates a CPU-backed [SkImage] by copying pixel data.
  ///
  /// Returns null if parameters are invalid. Valid parameters include:
  /// - dimensions greater than zero
  /// - each dimension fits in 29 bits
  /// - valid [SkColorType] and [SkAlphaType]
  /// - [rowBytes] large enough to hold one row of pixels
  /// - [pixels] is not null
  ///
  /// - [info]: Width, height, [SkAlphaType], [SkColorType], [SkColorSpace].
  /// - [pixels]: Address of pixel storage.
  /// - [rowBytes]: Size of pixel row or larger.
  static SkImage? rasterCopy(
    SkImageInfo info,
    Pointer<Void> pixels,
    int rowBytes,
  ) {
    final ptr = sk_image_new_raster_copy(
      info._ptr,
      pixels,
      rowBytes,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a CPU-backed [SkImage] from [SkPixmap], copying the pixel data.
  ///
  /// As a result, pixmap pixels may be modified or deleted without affecting
  /// [SkImage].
  ///
  /// Returns null if [SkPixmap] is invalid.
  static SkImage? rasterCopyWithPixmap(SkPixmap pixmap) {
    final ptr = sk_image_new_raster_copy_with_pixmap(pixmap._ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a CPU-backed [SkImage] from pixel data.
  ///
  /// The pixel data will *not* be copied - the [SkData] must remain valid.
  ///
  /// - [info]: Width, height, [SkAlphaType], [SkColorType], [SkColorSpace].
  /// - [pixels]: Pixel data storage.
  /// - [rowBytes]: Size of pixel row or larger.
  static SkImage? rasterData(SkImageInfo info, SkData pixels, int rowBytes) {
    final ptr = sk_image_new_raster_data(
      info._ptr,
      pixels._ptr,
      rowBytes,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a CPU-backed [SkImage] from compressed texture data.
  ///
  /// This method will decompress the compressed data and create an image
  /// wrapping it. Any mipmap levels present in the compressed data are
  /// discarded.
  ///
  /// - [data]: Compressed data to store in [SkImage].
  /// - [width]: Width of full [SkImage].
  /// - [height]: Height of full [SkImage].
  /// - [type]: Type of compression used.
  static SkImage? rasterFromCompressedTextureData(
    SkData data, {
    required int width,
    required int height,
    required SkTextureCompressionType type,
  }) {
    final ptr = sk_image_new_raster_from_compressed_texture_data(
      data._ptr,
      width,
      height,
      type._value,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a CPU-backed [SkImage] from bitmap, sharing or copying pixels.
  ///
  /// If the bitmap is marked immutable and its pixel memory is shareable, it
  /// may be shared instead of copied.
  ///
  /// Returns null if bitmap is invalid. Valid [SkBitmap] parameters include:
  /// - dimensions greater than zero
  /// - each dimension fits in 29 bits
  /// - valid [SkColorType] and [SkAlphaType]
  /// - row bytes large enough to hold one row of pixels
  /// - pixel address is not null
  static SkImage? fromBitmap(SkBitmap bitmap) {
    final ptr = sk_image_new_from_bitmap(bitmap._ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates an [SkImage] using encoded data, deferring decoding.
  ///
  /// This deferral allows the system to cache the result, either on the CPU
  /// or on the GPU, depending on where the image is drawn. If memory is low,
  /// the cache may be purged, causing the next draw of the image to have to
  /// re-decode.
  ///
  /// Returns null if the encoded format is not supported.
  static SkImage? fromEncoded(SkData data) {
    final ptr = sk_image_new_from_encoded(data._ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates an [SkImage] from [SkPicture].
  ///
  /// The Picture data is not turned into an image (CPU or GPU) until it is
  /// drawn.
  ///
  /// - [picture]: Stream of drawing commands.
  /// - [dimensions]: Width and height of the resulting image.
  /// - [matrix]: Transform to rotate, scale, translate, etc. May be null.
  /// - [paint]: Paint to apply transparency, filtering, etc. May be null.
  /// - [useFloatingPointBitDepth]: If true, uses 16-bit float per component
  ///   instead of 8-bit unsigned int.
  /// - [colorSpace]: Range of colors. May be null.
  /// - [props]: Surface properties for rasterizing the picture.
  static SkImage? fromPicture(
    SkPicture picture,
    SkISize dimensions, {
    Matrix3? matrix,
    SkPaint? paint,
    bool useFloatingPointBitDepth = false,
    SkColorSpace? colorSpace,
    SkSurfaceProps? props,
  }) {
    final ptr = sk_image_new_from_picture(
      picture._ptr,
      dimensions.toNativePooled(0),
      matrix?.toNativePooled(0) ?? nullptr,
      paint?._ptr ?? nullptr,
      useFloatingPointBitDepth,
      colorSpace?._ptr ?? nullptr,
      props?._ptr ?? nullptr,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  // Properties

  /// Returns an [SkImageInfo] describing the width, height, color type, alpha
  /// type, and color space of the [SkImage].
  SkImageInfo get imageInfo {
    final info = sk_image_get_info(_ptr);
    return SkImageInfo._(info);
  }

  /// Returns pixel count in each row.
  int get width => sk_image_get_width(_ptr);

  /// Returns pixel row count.
  int get height => sk_image_get_height(_ptr);

  /// Returns value unique to image.
  ///
  /// [SkImage] contents cannot change after [SkImage] is created. Any
  /// operation to create a new [SkImage] will generate a new unique number.
  int get uniqueId => sk_image_get_unique_id(_ptr);

  /// Returns [SkISize] containing [width] and [height].
  SkISize get dimensions => SkISize(width, height);

  /// Returns [SkIRect] from origin to [width] and [height].
  SkIRect get bounds => SkIRect.fromWH(width, height);

  /// Returns [SkAlphaType].
  ///
  /// [SkAlphaType] returned was a parameter to an [SkImage] constructor, or
  /// was parsed from encoded data.
  SkAlphaType get alphaType =>
      SkAlphaType.fromNative(sk_image_get_alpha_type(_ptr));

  /// Returns [SkColorType] if known; otherwise, returns [SkColorType.unknown].
  SkColorType get colorType =>
      SkColorType._fromNative(sk_image_get_color_type(_ptr));

  /// Returns [SkColorSpace], the range of colors, associated with [SkImage].
  ///
  /// The returned [SkColorSpace] is immutable. [SkColorSpace] returned may be
  /// ignored when [SkImage] is drawn, depending on the capabilities of the
  /// [SkSurface] receiving the drawing.
  ///
  /// Returns null if no color space is associated.
  SkColorSpace? get colorSpace {
    final ptr = sk_image_get_colorspace(_ptr);
    if (ptr == nullptr) return null;
    return SkColorSpace._(ptr);
  }

  /// Returns true if [SkImage] pixels represent transparency only.
  ///
  /// If true, each pixel is packed in 8 bits as defined by
  /// [SkColorType.alpha8].
  bool get isAlphaOnly => sk_image_is_alpha_only(_ptr);

  /// Returns true if pixels ignore their alpha value and are treated as fully
  /// opaque.
  bool get isOpaque => sk_image_is_opaque(_ptr);

  /// Returns true if the contents of [SkImage] was created on or uploaded to
  /// GPU memory, and is available as a GPU texture.
  bool get isTextureBacked => sk_image_is_texture_backed(_ptr);

  /// Returns an approximation of the amount of texture memory used by the
  /// image.
  ///
  /// Returns zero if the image is not texture backed or if the texture has an
  /// external format.
  int get textureSize => sk_image_texture_size(_ptr);

  /// Returns true if [SkImage] is backed by an image-generator or other
  /// service that creates and caches its pixels or texture on-demand.
  bool get isLazyGenerated => sk_image_is_lazy_generated(_ptr);

  /// Returns true if the image has mipmap levels.
  bool get hasMipmaps => sk_image_has_mipmaps(_ptr);

  /// Returns true if the image holds protected content.
  bool get isProtected => sk_image_is_protected(_ptr);

  // Methods

  /// Creates a shader with the specified tiling and mipmap sampling.
  ///
  /// - [tmx]: Tile mode for the X axis.
  /// - [tmy]: Tile mode for the Y axis.
  /// - [sampling]: Sampling options controlling interpolation.
  /// - [matrix]: Optional local matrix to apply to the shader.
  SkShader? makeShader(
    SkShaderTileMode tmx,
    SkShaderTileMode tmy, {
    SkSamplingOptions sampling = const SkSamplingOptions(),
    Matrix3? matrix,
  }) {
    final samplingPtr = _samplingOptionsPtr(sampling);
    final matrixPtr = matrix?.toNativePooled(0) ?? nullptr;
    try {
      final ptr = sk_image_make_shader(
        _ptr,
        tmx._value,
        tmy._value,
        samplingPtr,
        matrixPtr,
      );
      if (ptr == nullptr) return null;
      return SkShader._(ptr);
    } finally {
      _freeSamplingOptionsPtr(samplingPtr);
    }
  }

  /// Creates a raw shader for images containing non-color data.
  ///
  /// This includes images encoding things like normals, material properties
  /// (e.g., roughness), heightmaps, or any other purely mathematical data that
  /// happens to be stored in an image. These types of images are useful with
  /// some programmable shaders.
  ///
  /// Raw image shaders work like regular image shaders (including filtering
  /// and tiling), with a few major differences:
  /// - No color space transformation is ever applied (the color space of the
  ///   image is ignored).
  /// - Images with an alpha type of unpremultiplied are *not* automatically
  ///   premultiplied.
  /// - Bicubic filtering is not supported. If [SkSamplingOptions.useCubic] is
  ///   true, this will return null.
  ///
  /// - [tmx]: Tile mode for the X axis.
  /// - [tmy]: Tile mode for the Y axis.
  /// - [sampling]: Sampling options controlling interpolation.
  /// - [matrix]: Optional local matrix to apply to the shader.
  SkShader? makeRawShader(
    SkShaderTileMode tmx,
    SkShaderTileMode tmy, {
    SkSamplingOptions sampling = const SkSamplingOptions(),
    Matrix3? matrix,
  }) {
    final samplingPtr = _samplingOptionsPtr(sampling);
    final matrixPtr = matrix?.toNativePooled(0) ?? nullptr;
    try {
      final ptr = sk_image_make_raw_shader(
        _ptr,
        tmx._value,
        tmy._value,
        samplingPtr,
        matrixPtr,
      );
      if (ptr == nullptr) return null;
      return SkShader._(ptr);
    } finally {
      _freeSamplingOptionsPtr(samplingPtr);
    }
  }

  /// Copies [SkImage] pixel address, row bytes, and [SkImageInfo] to pixmap.
  ///
  /// Returns true if address is available, and [pixmap] is updated. If pixel
  /// address is not available, returns false and leaves [pixmap] unchanged.
  bool peekPixels(SkPixmap pixmap) {
    return sk_image_peek_pixels(_ptr, pixmap._ptr);
  }

  /// Returns true if [SkImage] can be drawn on the given context.
  ///
  /// If [context] is null, tests if [SkImage] draws on raster surface;
  /// otherwise, tests if [SkImage] draws on the associated GPU surface.
  ///
  /// [SkImage] backed by GPU texture may become invalid if associated context
  /// is invalid. Lazy image may be invalid and may not draw to raster surface
  /// or GPU surface or both.
  bool isValid(SkRecorder context) {
    return sk_image_is_valid(_ptr, context._recorderPtr);
  }

  /// Copies a rect of pixels from [SkImage] to [dstPixels].
  ///
  /// Copy starts at offset ([srcX], [srcY]), and does not exceed [SkImage]
  /// ([width], [height]).
  ///
  /// [dstInfo] specifies width, height, [SkColorType], [SkAlphaType], and
  /// [SkColorSpace] of destination. [dstRowBytes] specifies the gap from one
  /// destination row to the next.
  ///
  /// Returns true if pixels are copied. Returns false if:
  /// - [dstPixels] is null
  /// - [dstRowBytes] is less than [dstInfo.minRowBytes]
  ///
  /// Pixels are copied only if pixel conversion is possible.
  ///
  /// If [cachingHint] is [SkImageCachingHint.allow], pixels may be retained
  /// locally. If [cachingHint] is [SkImageCachingHint.disallow], pixels are
  /// not added to the local cache.
  bool readPixels(
    SkImageInfo dstInfo,
    Pointer<Void> dstPixels,
    int dstRowBytes, {
    int srcX = 0,
    int srcY = 0,
    SkImageCachingHint cachingHint = SkImageCachingHint.allow,
  }) {
    return sk_image_read_pixels(
      _ptr,
      dstInfo._ptr,
      dstPixels,
      dstRowBytes,
      srcX,
      srcY,
      cachingHint._value,
    );
  }

  /// Copies a rect of pixels from [SkImage] to [dst] pixmap.
  ///
  /// Copy starts at ([srcX], [srcY]), and does not exceed [SkImage]
  /// ([width], [height]).
  ///
  /// [dst] specifies width, height, [SkColorType], [SkAlphaType],
  /// [SkColorSpace], pixel storage, and row bytes of destination.
  ///
  /// Returns true if pixels are copied. Returns false if:
  /// - dst pixel storage is null
  /// - dst.rowBytes is less than [SkImageInfo.minRowBytes]
  bool readPixelsIntoPixmap(
    SkPixmap dst, {
    int srcX = 0,
    int srcY = 0,
    SkImageCachingHint cachingHint = SkImageCachingHint.allow,
  }) {
    return sk_image_read_pixels_into_pixmap(
      _ptr,
      dst._ptr,
      srcX,
      srcY,
      cachingHint._value,
    );
  }

  /// Copies [SkImage] to [dst], scaling pixels to fit dst.width and dst.height.
  ///
  /// Converts pixels to match dst.colorType and dst.alphaType. Returns true if
  /// pixels are copied. Returns false if dst.addr is null, or dst.rowBytes is
  /// less than dst [SkImageInfo.minRowBytes].
  ///
  /// Pixels are copied only if pixel conversion is possible.
  bool scalePixels(
    SkPixmap dst, {
    SkSamplingOptions sampling = const SkSamplingOptions(),
    SkImageCachingHint cachingHint = SkImageCachingHint.allow,
  }) {
    final samplingPtr = _samplingOptionsPtr(sampling);
    try {
      return sk_image_scale_pixels(
        _ptr,
        dst._ptr,
        samplingPtr,
        cachingHint._value,
      );
    } finally {
      _freeSamplingOptionsPtr(samplingPtr);
    }
  }

  /// Returns encoded [SkImage] pixels as [SkData], if [SkImage] was created
  /// from a supported encoded stream format.
  ///
  /// Platform support for formats vary and may require building with one or
  /// more of: SK_ENCODE_JPEG, SK_ENCODE_PNG, SK_ENCODE_WEBP.
  ///
  /// Returns null if [SkImage] contents are not encoded.
  SkData? get encodedData {
    final ptr = sk_image_ref_encoded(_ptr);
    if (ptr == nullptr) return null;
    return SkData._(ptr.cast());
  }

  /// Returns a raster-backed subset of this image.
  ///
  /// Returns null if:
  /// - [subset] is empty
  /// - [subset] is not contained inside the image's bounds
  /// - Pixels in the image could not be read or copied
  SkImage? makeSubsetRaster(SkIRect subset) {
    final ptr = sk_image_make_subset_raster(_ptr, subset.toNativePooled(0));
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Returns a subset of this image.
  ///
  /// Returns null if:
  /// - [subset] is empty
  /// - [subset] is not contained inside the image's bounds
  /// - Pixels in the image could not be read or copied
  /// - This image is texture-backed and [recorder] is null or does not match
  ///   the source image's context
  ///
  /// If the source image was texture-backed, the resulting image will be
  /// texture-backed also. Otherwise, the returned image will be raster-backed.
  SkImage? makeSubset(SkRecorder? recorder, SkIRect subset) {
    final ptr = sk_image_make_subset(
      _ptr,
      recorder?._recorderPtr ?? nullptr,
      subset.toNativePooled(0),
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Returns [SkImage] backed by GPU texture.
  ///
  /// Returns original [SkImage] if the image is already texture backed.
  /// Returns null if [context] is null, or if [SkImage] was created with
  /// another [GrDirectContext].
  ///
  /// - [context]: The GPU context.
  /// - [mipmapped]: Whether to generate mipmaps.
  /// - [budgeted]: Whether the texture should be counted against the cache
  ///   budget.
  SkImage? makeTextureImage(
    GrDirectContext context, {
    bool mipmapped = false,
    bool budgeted = true,
  }) {
    final ptr = sk_image_make_texture_image(
      _ptr,
      context._directContextPtr,
      mipmapped,
      budgeted,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Returns raster image or lazy image.
  ///
  /// Copies [SkImage] backed by GPU texture into CPU memory if needed. Returns
  /// original [SkImage] if decoded in raster bitmap, or if encoded in a stream.
  ///
  /// Returns null if backed by GPU texture and copy fails.
  SkImage? makeNonTextureImage() {
    final ptr = sk_image_make_non_texture_image(_ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Returns raster image.
  ///
  /// Copies [SkImage] backed by GPU texture into CPU memory, or decodes
  /// [SkImage] from lazy image. Returns original [SkImage] if decoded in
  /// raster bitmap.
  ///
  /// Returns null if copy, decode, or pixel read fails.
  SkImage? makeRasterImage() {
    final ptr = sk_image_make_raster_image(_ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Returns an image with the same "base" pixels as this image, but with
  /// mipmap levels automatically generated and attached.
  SkImage? withDefaultMipmaps() {
    final ptr = sk_image_with_default_mipmaps(_ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a new [SkImage] identical to this one, but with a different
  /// [SkColorSpace].
  ///
  /// This does not convert the underlying pixel data, so the resulting image
  /// will draw differently.
  SkImage? reinterpretColorSpace(SkColorSpace colorSpace) {
    final ptr = sk_image_reinterpret_color_space(_ptr, colorSpace._ptr);
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates [SkImage] in target [SkColorSpace].
  ///
  /// Returns null if [SkImage] could not be created. Returns original [SkImage]
  /// if it is in target [SkColorSpace]. Otherwise, converts pixels from
  /// [SkImage] [SkColorSpace] to target [SkColorSpace].
  ///
  /// If [SkImage.colorSpace] returns null, [SkImage] [SkColorSpace] is assumed
  /// to be sRGB.
  SkImage? makeColorSpace(
    SkColorSpace colorSpace, {
    SkRecorder? recorder,
    bool mipmapped = false,
  }) {
    final ptr = sk_image_make_color_space(
      _ptr,
      recorder?._recorderPtr ?? nullptr,
      colorSpace._ptr,
      mipmapped,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates [SkImage] in target [SkColorType] and [SkColorSpace].
  ///
  /// Returns null if [SkImage] could not be created. Returns original [SkImage]
  /// if it is in target [SkColorType] and [SkColorSpace].
  SkImage? makeColorTypeAndColorSpace(
    SkColorType colorType,
    SkColorSpace colorSpace, {
    SkRecorder? recorder,
    bool mipmapped = false,
  }) {
    final ptr = sk_image_make_color_type_and_color_space(
      _ptr,
      recorder?._recorderPtr ?? nullptr,
      colorType._value,
      colorSpace._ptr,
      mipmapped,
    );
    if (ptr == nullptr) return null;
    return SkImage._(ptr);
  }

  /// Creates a new image by copying this image and scaling to fit the
  /// [SkImageInfo]'s dimensions.
  ///
  /// This is done retaining the domain (backend) of the image (e.g., GPU,
  /// raster).
  ///
  /// Returns null if the requested [SkImageInfo] is not supported, its
  /// dimensions are out of range, or if the recorder is null on a graphite
  /// Image.
  SkImage? makeScaled(
    SkImageInfo info, {
    SkRecorder? recorder,
    SkSamplingOptions sampling = const SkSamplingOptions(),
    SkSurfaceProps? props,
  }) {
    final samplingPtr = _samplingOptionsPtr(sampling);
    try {
      final ptr = sk_image_make_scaled(
        _ptr,
        recorder?._recorderPtr ?? nullptr,
        info._ptr,
        samplingPtr,
        props?._ptr ?? nullptr,
      );
      if (ptr == nullptr) return null;
      return SkImage._(ptr);
    } finally {
      _freeSamplingOptionsPtr(samplingPtr);
    }
  }

  /// Creates a filtered [SkImage] on the CPU.
  ///
  /// [filter] processes the image, potentially changing the color, position,
  /// and size. [subset] is the bounds of source that are processed by filter.
  /// [clipBounds] is the expected bounds of the filtered [SkImage].
  ///
  /// Returns null if a filtered result could not be created. If null is
  /// returned, the output values are undefined.
  ///
  /// Useful for animation of [SkImageFilter] that varies size from frame to
  /// frame.
  ///
  /// Returns a record containing:
  /// - `image`: The filtered image
  /// - `outSubset`: The actual bounds of the filtered image
  /// - `outOffset`: Translation to keep subsequent animation frames aligned
  ({SkImage image, SkIRect outSubset, SkIPoint outOffset})?
  makeWithFilterRaster(
    SkImageFilter filter,
    SkIRect subset,
    SkIRect clipBounds,
  ) {
    final outSubsetPtr = _SkIRect.pool[1];
    final outOffsetPtr = _SkIPoint.pool[0];
    final ptr = sk_image_make_with_filter_raster(
      _ptr,
      filter._ptr,
      subset.toNativePooled(0),
      clipBounds.toNativePooled(2),
      outSubsetPtr,
      outOffsetPtr,
    );
    if (ptr == nullptr) return null;
    return (
      image: SkImage._(ptr),
      outSubset: _SkIRect.fromNative(outSubsetPtr),
      outOffset: _SkIPoint.fromNative(outOffsetPtr),
    );
  }

  /// Creates a filtered [SkImage] using GPU context.
  ///
  /// Similar to [makeWithFilterRaster] but uses GPU acceleration.
  ///
  /// - [context]: The GPU recording context.
  /// - [filter]: The image filter to apply.
  /// - [subset]: Bounds of source image processed by filter.
  /// - [clipBounds]: Expected bounds of the filtered image.
  ///
  /// Returns a record containing:
  /// - `image`: The filtered image
  /// - `outSubset`: The actual bounds of the filtered image
  /// - `outOffset`: Translation to keep subsequent animation frames aligned
  ({SkImage image, SkIRect outSubset, SkIPoint outOffset})? makeWithFilter(
    GrRecordingContext context,
    SkImageFilter filter,
    SkIRect subset,
    SkIRect clipBounds,
  ) {
    final outSubsetPtr = _SkIRect.pool[1];
    final outOffsetPtr = _SkIPoint.pool[0];
    final ptr = sk_image_make_with_filter(
      _ptr,
      context._ptr,
      filter._ptr,
      subset.toNativePooled(0),
      clipBounds.toNativePooled(2),
      outSubsetPtr,
      outOffsetPtr,
    );
    if (ptr == nullptr) return null;
    return (
      image: SkImage._(ptr),
      outSubset: _SkIRect.fromNative(outSubsetPtr),
      outOffset: _SkIPoint.fromNative(outOffsetPtr),
    );
  }

  static final _finalizer = _createFinalizer();

  static NativeFinalizer _createFinalizer() {
    final Pointer<NativeFunction<Void Function(Pointer<sk_image_t>)>> ptr =
        Native.addressOf(sk_image_unref);
    return NativeFinalizer(ptr.cast());
  }
}
