part of '../skia_dart.dart';

/// Specifies the style of blur to apply with [SkMaskFilter.blur].
///
/// The blur style determines which parts of the shape are affected by the blur.
enum SkBlurStyle {
  /// Fuzzy inside and outside the original shape.
  ///
  /// This is the standard blur effect that extends in all directions.
  normal(sk_blurstyle_t.NORMAL_SK_BLUR_STYLE),

  /// Solid inside, fuzzy outside.
  ///
  /// The original shape remains solid while the blur extends outward.
  solid(sk_blurstyle_t.SOLID_SK_BLUR_STYLE),

  /// Nothing inside, fuzzy outside.
  ///
  /// Only the outer blur is drawn; the inside of the shape is transparent.
  /// Useful for creating glow or halo effects.
  outer(sk_blurstyle_t.OUTER_SK_BLUR_STYLE),

  /// Fuzzy inside, nothing outside.
  ///
  /// The blur is constrained to the inside of the original shape.
  /// Useful for creating inner shadow or pillow effects.
  inner(sk_blurstyle_t.INNER_SK_BLUR_STYLE)
  ;

  final sk_blurstyle_t _value;
  const SkBlurStyle(this._value);
}

/// Performs transformations on the mask before drawing it.
///
/// [SkMaskFilter] is the base class for objects that modify the alpha mask
/// generated by a shape before it is drawn. The most common example is blur.
///
/// Mask filters operate on the alpha channel of the drawn shape and affect
/// the final rasterization. They are applied after the shape is converted to
/// a mask but before the paint's color and other effects are applied.
///
/// Example:
/// ```dart
/// // Create a blur mask filter
/// final blur = SkMaskFilter.blur(
///   style: SkBlurStyle.normal,
///   sigma: 5.0,
/// );
///
/// // Apply to paint
/// paint.maskFilter = blur;
///
/// // Draw with blur effect
/// canvas.drawCircle(center, radius, paint);
///
/// blur.dispose();
/// ```
class SkMaskFilter with _NativeMixin<sk_maskfilter_t> {
  SkMaskFilter._(Pointer<sk_maskfilter_t> ptr) {
    _attach(ptr, _finalizer);
  }

  /// Creates a blur mask filter.
  ///
  /// - [style]: The [SkBlurStyle] to use, controlling which parts of the shape
  ///   are blurred.
  /// - [sigma]: Standard deviation of the Gaussian blur to apply. Must be > 0.
  ///   Larger values produce more blur.
  /// - [respectCTM]: If true (default), the blur's sigma is modified by the
  ///   current transformation matrix (CTM). If false, the blur radius remains
  ///   constant regardless of canvas transformations.
  factory SkMaskFilter.blur({
    required SkBlurStyle style,
    required double sigma,
    bool respectCTM = true,
  }) {
    return SkMaskFilter._(
      sk_maskfilter_new_blur(style._value, sigma, respectCTM),
    );
  }

  /// Creates a table-based mask filter.
  ///
  /// The [table] must be exactly 256 bytes. Each byte in the table maps an
  /// input alpha value (0-255) to an output alpha value. This allows for
  /// arbitrary remapping of the mask's alpha channel.
  ///
  /// Example: To create a threshold effect, fill the table with 0 for values
  /// below the threshold and 255 for values at or above.
  factory SkMaskFilter.table(Uint8List table) {
    assert(table.length == 256);
    final ptr = ffi.calloc<Uint8>(256);
    try {
      ptr.asTypedList(256).setAll(0, table);
      return SkMaskFilter._(sk_maskfilter_new_table(ptr));
    } finally {
      ffi.calloc.free(ptr);
    }
  }

  /// Creates a gamma correction mask filter.
  ///
  /// Applies a gamma curve to the mask's alpha values. The [gamma] parameter
  /// controls the curve:
  /// - gamma < 1.0: Makes the mask lighter (expands mid-tones)
  /// - gamma = 1.0: No change
  /// - gamma > 1.0: Makes the mask darker (compresses mid-tones)
  factory SkMaskFilter.gamma(double gamma) {
    return SkMaskFilter._(sk_maskfilter_new_gamma(gamma));
  }

  /// Creates a clip mask filter that clamps alpha values to a range.
  ///
  /// Alpha values below [min] are set to 0, values above [max] are set to 255,
  /// and values between are linearly interpolated.
  ///
  /// - [min]: Minimum alpha value (0-255). Values below this become transparent.
  /// - [max]: Maximum alpha value (0-255). Values above this become fully opaque.
  factory SkMaskFilter.clip({
    required int min,
    required int max,
  }) {
    return SkMaskFilter._(sk_maskfilter_new_clip(min, max));
  }

  /// Creates a shader-based mask filter.
  ///
  /// The [shader] is evaluated to determine the mask's alpha values. This
  /// allows for complex, procedural mask effects using any shader type
  /// (gradients, images, noise, etc.).
  factory SkMaskFilter.shader(SkShader shader) {
    return SkMaskFilter._(sk_maskfilter_new_shader(shader._ptr));
  }

  @override
  void dispose() {
    _dispose(sk_maskfilter_unref, _finalizer);
  }

  static final _finalizer = _createFinalizer();

  static NativeFinalizer _createFinalizer() {
    final Pointer<NativeFunction<Void Function(Pointer<sk_maskfilter_t>)>> ptr =
        Native.addressOf(sk_maskfilter_unref);
    return NativeFinalizer(ptr.cast());
  }
}
